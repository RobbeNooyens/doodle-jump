# Doodle Jump
Bachelor in Computer Science - University of Antwerp

## SFML Library

SFML can be downloaded from https://www.sfml-dev.org/download.php.
> Simple and Fast Multimedia Library (SFML) is a cross-platform software development library designed to provide a simple application programming interface (API) to various multimedia components in computers. - Wikipedia

## Install and run

 1. Download or clone the repository
 2. Make sure you have the SFML library installed
 3. Set it up as a CMake project
 4. Select the right target: DoodleJump
 5. Build the sourcecode
 6. Run the generated executable from the project root directory

## General overview

In this report, I’ll talk about how I implemented the game, the design I’ve used and why I’ve made certain choises. First of all, I’ll explain the general structure of the project. When the program starts, a new Game object is instantiated. This object creates the EntityFacotry and the GUI wrapper factory, which will be used to create the GUI elements. Once they’re created, it lets the TextureLoader load the sprite textures with these factories. In the game loop itself, a GameStateController will be used to control the current state and it’s corresponding screen. If the game is in it’s GamePlayingState, a World instance will be around, managing different kinds of EntityControllers generated by the WorldGenerator. Each controller is created by the EntityFactory and passes updates to its model and view. The model handles the entities’ logic and internal game representation, while the view takes care of the visualization. The score increases if one of the following situations occur: the player reaches a new maximum height, the player bounces on a platform or the player uses a bonus. The increase amount varies from situation to situation, depending on the difference with the previous max height, the platform type, the bonus type, … It decreases if the player jumps more than once on the same platform. In order to detect these collisions, every entity stores its own bounding box. This implies that the game can internally run as a bunch of bounding boxes, without the need for visual representations. Last but not least, the EventManager manages the EventHandlers and the Events with the Observer pattern. This way, all objects that rely on specific event invocations can be updated with one simple function call. 

## Polymorphism

In order to minimize code duplication, I’ve used several abstract classes. The most obvious ones are the EntityController, EntityModel and EntityView. They contain the common functions shared among the entities for either their controller, model or view. As stated before, the EventManager notifies different kind of game events to its handlers. The base class for such an event has the corresponding name Event and can be inherited to create new event types. Sometimes an exception can occur. The Exception class provides a simple link with the standard exception library and can easily be derived for new exception types. If a fatal exception occurs during the game, the GameStateController will put the game in an error state. This error state is one of the four derived classes of the GameState, another abstract class used in this project.

## Design patterns

This project contains multiple design patterns that I’ll explain separately.

**Model-View-Controller**: This is the base design pattern used for the game entities. Each entity has its own model, view, and controller subclass. The controllers are used by the world to interact with the entities, the models are notified by the controllers on changes to handle the logic and the view stores and manages a reference to its graphical representation.

**Observer**: The idea behind this pattern is used for invoking events and notifying EventHandlers.  The EventManager is an observable which stores a list of these handlers, acting like observers. This facilitates the interactions between objects that aren’t directly related to each other, but rely on each others’ state changes.

**Singleton**: The Stopwatch, Random, ScoreManager and TextureLoader are singletons. This pattern enforces that only one instance is being instantiated and used during the execution of the program. This is useful to prevent different instances creating their own unsynchronized timers for example. The random class can generate random numbers between a given range and pick a random item from a weighted list. On top of that, the random class also uses template functions to allow different types to operate on. The ScoreManager manages the score and highscore. The singleton pattern ensures that the entities can access these scores from anywhere in the code and it ensures that there’s only one reference to the highscore during the entire game to prevent code duplication. The TextureLoader is a singleton so it only has to load the sprites once and so that they can be accessed where needed.

**Abstract factory**: This is a useful creational design pattern used to create objects without knowledge about the implementation. One of the factories I’ve used in this project is the EntityFactory. This factory provides an interface to create EntityControllers, used by the World to interact with the entities. The other factory is the WrapperFactory. It creates wrappers or adapters for the graphical components which I’ll explain in the next paragraph.

**Adapter**: The adapter or wrapper pattern used in this project provides a link between a specific GUI library and the abstract representation of a sprite, texture, window, … This allows to compile the game logic without the SFML library and to use a different library just by implementing the abstract wrapper methods.

**State**: Since the game consists of a few specific states, I’ve decided to use the state design pattern to update and draw the window. The GameStateController is an intermediate step between the Game and the GameState, which makes it possible to inherit from Event and listen to game events.

## Namespaces

**models**: contains the entity model implementations

**views**: contains the entity view representations

**controllers**: contains the entity controllers to interact with

**events**: contains the game events

**wrappers**: contains the GUI wrappers

**wrappers::sf**: contains the SFML wrapper implementations

**exceptions**: contains the exceptions


## Warning

*Plagiarism is illegal and will have consequences. Do NOT copy parts of this repository claiming it's your own work.*
